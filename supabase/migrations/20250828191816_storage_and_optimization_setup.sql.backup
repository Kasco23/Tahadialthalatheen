-- ============================================
-- STORAGE AND OPTIMIZATION SETUP
-- Date: 2025-01-28
-- Author: GitHub Copilot Supabase Architect
-- ============================================

-- ============================================
-- STORAGE POLICIES FOR EXISTING BUCKETS
-- Note: User already has "images" bucket with assets/ and team-logos/ folders
-- ============================================

-- Create storage policies for the existing "images" bucket
-- This bucket contains assets/ and team-logos/ subfolders

-- Public read access for all images (already public bucket)
CREATE POLICY "images_public_read" ON storage.objects
  FOR SELECT TO public
  USING (bucket_id = 'images');

-- Authenticated users can upload to assets folder
CREATE POLICY "images_assets_upload" ON storage.objects
  FOR INSERT TO authenticated
  WITH CHECK (
    bucket_id = 'images' AND
    (storage.foldername(name))[1] = 'assets' AND
    storage.extension(name) IN ('jpg', 'jpeg', 'png', 'webp', 'svg', 'gif')
  );

-- Authenticated users can upload to team-logos folder
CREATE POLICY "images_team_logos_upload" ON storage.objects
  FOR INSERT TO authenticated
  WITH CHECK (
    bucket_id = 'images' AND
    (storage.foldername(name))[1] = 'team-logos' AND
    storage.extension(name) IN ('jpg', 'jpeg', 'png', 'webp', 'svg')
  );

-- Game hosts can manage assets and team logos
CREATE POLICY "images_host_management" ON storage.objects
  FOR UPDATE TO authenticated
  USING (
    bucket_id = 'images' AND
    (storage.foldername(name))[1] IN ('assets', 'team-logos') AND
    EXISTS (
      SELECT 1 FROM public.games 
      WHERE host_id = auth.uid()
    )
  )
  WITH CHECK (
    bucket_id = 'images' AND
    (storage.foldername(name))[1] IN ('assets', 'team-logos') AND
    EXISTS (
      SELECT 1 FROM public.games 
      WHERE host_id = auth.uid()
    )
  );

CREATE POLICY "images_host_delete" ON storage.objects
  FOR DELETE TO authenticated
  USING (
    bucket_id = 'images' AND
    (storage.foldername(name))[1] IN ('assets', 'team-logos') AND
    EXISTS (
      SELECT 1 FROM public.games 
      WHERE host_id = auth.uid()
    )
  );

-- Create avatars bucket for user profile images (if not exists)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'avatars', 
  'avatars', 
  true, 
  5242880, -- 5MB limit
  ARRAY['image/jpeg', 'image/png', 'image/webp', 'image/gif']
) ON CONFLICT (id) DO NOTHING;

-- Create recordings bucket for game session recordings (private, if not exists)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'recordings', 
  'recordings', 
  false, 
  104857600, -- 100MB limit
  ARRAY['video/mp4', 'video/webm', 'audio/webm', 'audio/mpeg']
) ON CONFLICT (id) DO NOTHING;

-- ============================================
-- STORAGE RLS POLICIES
-- ============================================

-- Storage policies for existing "images" bucket (drop existing if any)
DROP POLICY IF EXISTS "images_public_read" ON storage.objects;
DROP POLICY IF EXISTS "images_assets_upload" ON storage.objects;
DROP POLICY IF EXISTS "images_team_logos_upload" ON storage.objects;
DROP POLICY IF EXISTS "images_host_management" ON storage.objects;
DROP POLICY IF EXISTS "images_host_delete" ON storage.objects;

-- Storage policies for avatars bucket (drop existing if any)
DROP POLICY IF EXISTS "avatars_public_read" ON storage.objects;
DROP POLICY IF EXISTS "avatars_authenticated_upload" ON storage.objects;
DROP POLICY IF EXISTS "avatars_owner_update" ON storage.objects;
DROP POLICY IF EXISTS "avatars_owner_delete" ON storage.objects;

-- Storage policies for recordings bucket (drop existing if any)
DROP POLICY IF EXISTS "recordings_host_access" ON storage.objects;
DROP POLICY IF EXISTS "recordings_host_upload" ON storage.objects;
DROP POLICY IF EXISTS "recordings_host_delete" ON storage.objects;

-- Avatars bucket policies (public read, authenticated upload/update)
CREATE POLICY "avatars_public_read" ON storage.objects
  FOR SELECT TO public
  USING (bucket_id = 'avatars');

CREATE POLICY "avatars_authenticated_upload" ON storage.objects
  FOR INSERT TO authenticated
  WITH CHECK (
    bucket_id = 'avatars' AND
    (storage.foldername(name))[1] = auth.uid()::text AND -- User can only upload to their own folder
    storage.extension(name) IN ('jpg', 'jpeg', 'png', 'webp', 'gif')
  );

CREATE POLICY "avatars_owner_update" ON storage.objects
  FOR UPDATE TO authenticated
  USING (
    bucket_id = 'avatars' AND
    (storage.foldername(name))[1] = auth.uid()::text -- User can only update their own files
  )
  WITH CHECK (
    bucket_id = 'avatars' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY "avatars_owner_delete" ON storage.objects
  FOR DELETE TO authenticated
  USING (
    bucket_id = 'avatars' AND
    (storage.foldername(name))[1] = auth.uid()::text -- User can only delete their own files
  );

-- Avatars bucket policies (public read, authenticated upload/update)
CREATE POLICY "avatars_public_read" ON storage.objects
  FOR SELECT TO public
  USING (bucket_id = 'avatars');

CREATE POLICY "avatars_authenticated_upload" ON storage.objects
  FOR INSERT TO authenticated
  WITH CHECK (
    bucket_id = 'avatars' AND
    (storage.foldername(name))[1] = auth.uid()::text AND -- User can only upload to their own folder
    storage.extension(name) IN ('jpg', 'jpeg', 'png', 'webp', 'gif')
  );

CREATE POLICY "avatars_owner_update" ON storage.objects
  FOR UPDATE TO authenticated
  USING (
    bucket_id = 'avatars' AND
    (storage.foldername(name))[1] = auth.uid()::text -- User can only update their own files
  )
  WITH CHECK (
    bucket_id = 'avatars' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY "avatars_owner_delete" ON storage.objects
  FOR DELETE TO authenticated
  USING (
    bucket_id = 'avatars' AND
    (storage.foldername(name))[1] = auth.uid()::text -- User can only delete their own files
  );

-- Recordings bucket policies (private, host only)
CREATE POLICY "recordings_host_access" ON storage.objects
  FOR SELECT TO authenticated
  USING (
    bucket_id = 'recordings' AND
    -- Extract game_id from file path: recordings/game_id/filename
    EXISTS (
      SELECT 1 FROM public.games 
      WHERE id = (storage.foldername(name))[1] 
      AND host_id = auth.uid()
    )
  );

CREATE POLICY "recordings_host_upload" ON storage.objects
  FOR INSERT TO authenticated
  WITH CHECK (
    bucket_id = 'recordings' AND
    storage.extension(name) IN ('mp4', 'webm', 'mp3') AND
    -- Must be uploading to a game they host
    EXISTS (
      SELECT 1 FROM public.games 
      WHERE id = (storage.foldername(name))[1] 
      AND host_id = auth.uid()
    )
  );

CREATE POLICY "recordings_host_delete" ON storage.objects
  FOR DELETE TO authenticated
  USING (
    bucket_id = 'recordings' AND
    EXISTS (
      SELECT 1 FROM public.games 
      WHERE id = (storage.foldername(name))[1] 
      AND host_id = auth.uid()
    )
  );

-- ============================================
-- ADVANCED PERFORMANCE OPTIMIZATIONS
-- ============================================

-- Composite indexes for complex queries
CREATE INDEX IF NOT EXISTS idx_players_game_connection 
ON public.players (game_id, connection_status) 
WHERE connection_status = 'online';

CREATE INDEX IF NOT EXISTS idx_games_status_host 
ON public.games (status, host_id);

CREATE INDEX IF NOT EXISTS idx_game_events_type_timestamp 
ON public.game_events (event_type, created_at DESC);

-- Partial indexes for better performance on common queries
CREATE INDEX IF NOT EXISTS idx_games_waiting 
ON public.games (created_at DESC) 
WHERE status = 'waiting';

CREATE INDEX IF NOT EXISTS idx_rooms_active 
ON public.rooms (game_id, expires_at) 
WHERE is_active = true;

-- Storage indexes are managed by Supabase internally
-- We cannot create custom indexes on storage.objects table

-- ============================================
-- ADVANCED UTILITY FUNCTIONS
-- ============================================

-- Function to get user's avatar URL with fallback
CREATE OR REPLACE FUNCTION public.get_user_avatar_url(user_id_param uuid)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  avatar_path text;
  public_url text;
BEGIN
  -- Check if user has uploaded avatar
  SELECT name INTO avatar_path
  FROM storage.objects
  WHERE bucket_id = 'avatars'
  AND (metadata->>'owner_id')::uuid = user_id_param
  ORDER BY created_at DESC
  LIMIT 1;
  
  IF avatar_path IS NOT NULL THEN
    -- Generate public URL for avatar
    SELECT 
      concat(
        current_setting('app.settings.supabase_url', true),
        '/storage/v1/object/public/avatars/',
        avatar_path
      ) INTO public_url;
    RETURN public_url;
  ELSE
    -- Return default avatar
    RETURN 'https://ui-avatars.com/api/?name=' || user_id_param::text;
  END IF;
END;
$$;

-- Function to cleanup old game recordings
CREATE OR REPLACE FUNCTION public.cleanup_old_recordings(days_old integer DEFAULT 30)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  deleted_count integer := 0;
  rec RECORD;
BEGIN
  -- Delete storage objects first
  FOR rec IN
    SELECT name
    FROM storage.objects
    WHERE bucket_id = 'recordings'
    AND created_at < (now() - interval '1 day' * days_old)
  LOOP
    -- Delete from storage (this would need to be done via storage API in practice)
    -- For now, just mark for cleanup
    UPDATE storage.objects 
    SET metadata = jsonb_set(metadata, '{marked_for_deletion}', 'true')
    WHERE bucket_id = 'recordings' 
    AND name = rec.name;
    
    deleted_count := deleted_count + 1;
  END LOOP;
  
  RETURN deleted_count;
END;
$$;

-- Function to get game statistics for analytics
CREATE OR REPLACE FUNCTION public.get_game_statistics(game_id_param text)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  stats json;
  is_authorized boolean := false;
BEGIN
  -- Security check: user must be in the game or be the host
  SELECT (public.is_game_participant(game_id_param) OR public.is_game_host(game_id_param))
  INTO is_authorized;
  
  IF NOT is_authorized THEN
    RAISE EXCEPTION 'Access denied';
  END IF;
  
  SELECT json_build_object(
    'game_id', g.id,
    'status', g.status,
    'duration_minutes', EXTRACT(EPOCH FROM (now() - g.created_at)) / 60,
    'player_count', (
      SELECT count(*) FROM public.players WHERE game_id = g.id
    ),
    'event_count', (
      SELECT count(*) FROM public.game_events WHERE game_id = g.id
    ),
    'active_players', (
      SELECT count(*) FROM public.players 
      WHERE game_id = g.id AND connection_status = 'online'
    ),
    'total_score', (
      SELECT COALESCE(sum(score), 0) FROM public.players WHERE game_id = g.id
    ),
    'top_player', (
      SELECT json_build_object('name', display_name, 'score', score)
      FROM public.players 
      WHERE game_id = g.id 
      ORDER BY score DESC 
      LIMIT 1
    )
  ) INTO stats
  FROM public.games g
  WHERE g.id = game_id_param;
  
  RETURN stats;
END;
$$;

-- Function to optimize player connections (mark offline if last_seen > 5 minutes)
CREATE OR REPLACE FUNCTION public.update_player_connections()
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  updated_count integer;
BEGIN
  UPDATE public.players 
  SET connection_status = 'offline'
  WHERE connection_status IN ('online', 'away')
  AND last_seen < (now() - interval '5 minutes');
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$;

-- Function to auto-complete games with no activity
CREATE OR REPLACE FUNCTION public.auto_complete_inactive_games(hours_inactive integer DEFAULT 2)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  completed_count integer;
BEGIN
  UPDATE public.games 
  SET status = 'completed', last_activity = now()
  WHERE status IN ('waiting', 'active')
  AND last_activity < (now() - interval '1 hour' * hours_inactive)
  AND NOT EXISTS (
    SELECT 1 FROM public.players 
    WHERE game_id = games.id 
    AND connection_status = 'online'
  );
  
  GET DIAGNOSTICS completed_count = ROW_COUNT;
  RETURN completed_count;
END;
$$;

-- ============================================
-- MAINTENANCE CRON-STYLE FUNCTIONS
-- ============================================

-- Master cleanup function to be called periodically
CREATE OR REPLACE FUNCTION public.run_maintenance_tasks()
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  results json;
  rooms_cleaned integer;
  players_updated integer;
  games_completed integer;
  recordings_marked integer;
BEGIN
  -- Run all maintenance tasks
  SELECT public.cleanup_expired_rooms() INTO rooms_cleaned;
  SELECT public.update_player_connections() INTO players_updated;
  SELECT public.auto_complete_inactive_games() INTO games_completed;
  SELECT public.cleanup_old_recordings() INTO recordings_marked;
  
  -- Build results object
  SELECT json_build_object(
    'timestamp', now(),
    'expired_rooms_cleaned', rooms_cleaned,
    'players_marked_offline', players_updated,
    'games_auto_completed', games_completed,
    'old_recordings_marked', recordings_marked
  ) INTO results;
  
  -- Log maintenance run
  INSERT INTO public.game_events (game_id, event_type, data)
  VALUES ('SYSTEM', 'MAINTENANCE_RUN', results);
  
  RETURN results;
END;
$$;

-- ============================================
-- ENHANCED TRIGGERS
-- ============================================

-- Auto-update game last_activity when players join/leave
CREATE OR REPLACE FUNCTION public.update_game_activity()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE public.games 
  SET last_activity = now() 
  WHERE id = COALESCE(NEW.game_id, OLD.game_id);
  
  RETURN COALESCE(NEW, OLD);
END;
$$;

CREATE TRIGGER update_game_activity_on_player_change
  AFTER INSERT OR UPDATE OR DELETE ON public.players
  FOR EACH ROW
  EXECUTE FUNCTION public.update_game_activity();

-- Auto-sequence game events
CREATE OR REPLACE FUNCTION public.auto_sequence_events()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.sequence_number := COALESCE(
    (SELECT max(sequence_number) FROM public.game_events WHERE game_id = NEW.game_id),
    0
  ) + 1;
  
  RETURN NEW;
END;
$$;

CREATE TRIGGER auto_sequence_game_events
  BEFORE INSERT ON public.game_events
  FOR EACH ROW
  EXECUTE FUNCTION public.auto_sequence_events();

-- ============================================
-- COMMENTS AND DOCUMENTATION
-- ============================================

COMMENT ON FUNCTION public.get_user_avatar_url(uuid) IS 'Get user avatar URL with fallback to generated avatar';
COMMENT ON FUNCTION public.cleanup_old_recordings(integer) IS 'Mark old game recordings for deletion';
COMMENT ON FUNCTION public.get_game_statistics(text) IS 'Get comprehensive game analytics and statistics';
COMMENT ON FUNCTION public.update_player_connections() IS 'Mark inactive players as offline';
COMMENT ON FUNCTION public.auto_complete_inactive_games(integer) IS 'Auto-complete games with no recent activity';
COMMENT ON FUNCTION public.run_maintenance_tasks() IS 'Master function for all maintenance operations';
